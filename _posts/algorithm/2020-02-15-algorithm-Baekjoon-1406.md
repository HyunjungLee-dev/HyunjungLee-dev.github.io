---
title:  "[algorithm]BAEKJOON 백준 1406번 에디터"
comments: true
toc : true
toc_sticky : true
categories:
  - algorithm
tags:
  - Baekjoon
  - C++
  - algorithm
---

# Baekjoon Online Judge No.1406

[https://www.acmicpc.net/problem/1406](https://www.acmicpc.net/problem/1406)

## 문제

한 줄로 된 간단한 에디터를 구현하려고 한다. 이 편집기는 영어 소문자만을 기록할 수 있는 편집기로, 최대 600,000글자까지 입력할 수 있다.

이 편집기에는 '커서'라는 것이 있는데, 커서는 문장의 맨 앞(첫 번째 문자의 왼쪽), 문장의 맨 뒤(마지막 문자의 오른쪽), 또는 문장 중간 임의의 곳(모든 연속된 두 문자 사이)에 위치할 수 있다. 즉 길이가 L인 문자열이 현재 편집기에 입력되어 있으면, 커서가 위치할 수 있는 곳은 L+1가지 경우가 있다.

이 편집기가 지원하는 명령어는 다음과 같다.

| L    | 커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨)  |
| :--- | ------------------------------------------------------------ |
| D    | 커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨) |
| B    | 커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨) 삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임 |
| P $  | $라는 문자를 커서 왼쪽에 추가함                              |

초기에 편집기에 입력되어 있는 문자열이 주어지고, 그 이후 입력한 명령어가 차례로 주어졌을 때, 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 구하는 프로그램을 작성하시오. 단, 명령어가 수행되기 전에 커서는 문장의 맨 뒤에 위치하고 있다고 한다.

## 알고리즘 분류

- 스택

## 입력

첫째 줄에는 초기에 편집기에 입력되어 있는 문자열이 주어진다. 이 문자열은 길이가 N이고, 영어 소문자로만 이루어져 있으며, 길이는 100,000을 넘지 않는다. 둘째 줄에는 입력할 명령어의 개수를 나타내는 정수 M(1 ≤ M ≤ 500,000)이 주어진다. 셋째 줄부터 M개의 줄에 걸쳐 입력할 명령어가 순서대로 주어진다. 명령어는 위의 네 가지 중 하나의 형태로만 주어진다.

## 출력

첫째 줄에 모든 명령어를 수행하고 난 후 편집기에 입력되어 있는 문자열을 출력한다.



## 예제 입력 1

```
abcd
3
P x
L
P y
```

## 예제 출력 1

```
abcdyx
```

## 예제 입력 2

```
abc
9
L
L
L
L
L
P x
L
B
P y
```

## 예제 출력 2

```
yxabc
```

## 예제 입력 3

```
dmih
11
B
B
P x
L
B
B
B
P y
D
D
P z
```

## 예제 출력 3

```
yxz
```



## 코드

```c++
#include <iostream>
#include <stack>
#include<string>
using namespace std;

int main() {
	
	string str;
	char ch;
	int num;

	cin >> str;
	cin >> num;

	stack<char>st1, st2;


	for (int i = 0; i < str.length(); i++)
	{
		st1.push(str[i]);
	}

	for (int i = 0; i < num; i++)
	{
		cin >> ch;

		if (ch == 'L')
		{
			if (st1.size()> 0)
			{
				st2.push(st1.top());
				st1.pop();
			}
		}
		else if (ch == 'D')
		{
			if (st2.size() > 0)
			{
				st1.push(st2.top());
				st2.pop();
			}
		}
		else if (ch == 'B')
		{
			if (st1.size() > 0)
				st1.pop();
		}
		else if (ch == 'P')
		{
			char add;
			cin >> add;
			st1.push(add);
		}
	}


	for (int i=st1.size(); i>0 ; i--)
	{
		st2.push( st1.top());
		st1. pop();
	}


	for (int i = st2.size(); i > 0; i--)
	{

			cout << st2.top();
			st2.pop();

	}
	return 0;
}
```

**들어가며**

런타임 에려고 나고 틀렸다는 결과도 받은 문제이다. 그 이유는 변수명을 간단하게 지었다는 이유가 가장 큰 것 같다. st1이라고 적어야 하는 곳을 2라고 적었다던가 그런 사소한 이유였다. 이런 경우 컴파일할 때는 오류가 나지 않아 코드를 하나씩 살펴 봐야 하는데 이것 또한 변수명이 구분이 어려우면 찾기가 어려워진다.  이와 같은 짧은 코드는 어느 정도 보면 찾을 수 있지만 길어지게 되면 어디서 오류가 생겼는지 찾기 어렵게 될 가능성이 크다. 짧은 코드라도 변수명에 신경을 쓰자.

**코드 이야기**

이번 1406번 에디터 문제의 경우 스택 문제이다. 스택이 아니어도 풀 수 있는 문제지만 스택을 이용하여 풀기 위해서는 주어진 문제를 스택으로 어떻게 구현을 해야 할까 하는 생각으로 시작하게 된다.

```c++
#include <iostream>
#include <stack>
#include<string>
using namespace std;ㅊ
```

코드 작성을 시작할 때 입력하는 부분이다. 입출력이 필요하고 라이브러리에 stack을 이용하고 문자열 받을 때는 string을 사용하기 위해 string까지 추가해줬다.

```c++
string str;
	char ch;
	int num;

	cin >> str;
	cin >> num;

	stack<char>st1, st2;

```

메인 함수로 들어가서 문자열을 받을 str, 명령어를 받을 ch,  명령어를 몇 개 받을지에 대한 num 과 같은 변수를 적어주고 cin을 통해 입력받았다. 그리고 stack의 경우 st1과 st2가 있는데 데이터를 넣고 커서의 기준으로 오른쪽과 왼쪽을 구분해주고 마지막으로 출력까지 하기 위해 하나가 아닌 둘을 이용한다.

```c++
for (int i = 0; i < str.length(); i++)
	{
		st1.push(str[i]);
	}
```

먼저 입력받은 문자열을 스택에 push를 통해 넣어준다. 이때 string.h 헤더 파일에 선언되어 있는 length 속성을 이용하여 문자열의 길이만큼 반복해준다.

```c++
	for (int i = 0; i < num; i++)
	{
		cin >> ch;

		if (ch == 'L')
		{
			if (st1.size()> 0)
			{
				st2.push(st1.top());
				st1.pop();
			}
		}
		else if (ch == 'D')
		{
			if (st2.size() > 0)
			{
				st1.push(st2.top());
				st2.pop();
			}
		}
		else if (ch == 'B')
		{
			if (st1.size() > 0)
				st1.pop();
		}
		else if (ch == 'P')
		{
			char add;
			cin >> add;
			st1.push(add);
		}
	}

```

이 부분은 명령어를 입력받고  'L' 'D' 'B' 'P' 중 어떤 명령어가 입력되었는지 확인하여 해당 명령어에 맞는 동작을 하도록 한다.

```c++
if (ch == 'L')
		{
			if (st1.size()> 0)
			{
				st2.push(st1.top());
				st1.pop();
			}
		}
```

먼저 'L' 의 경우이다. 이 명령어는 커서를 왼쪽으로 한 칸 옮김 (커서가 문장의 맨 앞이면 무시됨) 와 같은 동작을 해야 한다. 먼저 if 문인데 size가 0보다 클 경우이다. 0보다 작은 경우는 입력받은 문자열이 스택에 들어가 있지 않거나(처음 명령어를 입력할 경우) 혹은 커서가 맨 앞일 경우를 의미한다.  st2 에 push로 st1의 top을 넣어주게 되는데 실제로 커서가 있다고 생각해보면 커서를 왼쪽으로 이동했을 때 st1은 커서의 왼쪽에 있는 것만 가지게 된다고 생각하면 된다. st2는 커서의 오른쪽에 있는 것을 가지게 되는 것이다.

```c++
else if (ch == 'D')
		{
			if (st2.size() > 0)
			{
				st1.push(st2.top());
				st2.pop();
			}
		}
```

'D' 의 경우는 커서를 오른쪽으로 한 칸 옮김 (커서가 문장의 맨 뒤이면 무시됨)'과 같은 동작을 해야 한다. 'L' 에 대한 얘기를 할 때 st1은 커서의 왼쪽 st2는 커서의 오른쪽이라고 했다. 그렇다면 커서를 오른쪽으로 한 칸 옮기려면 어떻게 해야 할까? 생각해보면 커서를 오른쪽으로 한 칸 옮기게 되면 오른쪽에 있는 글자가 커서의 왼쪽으로 옮겨가게 된다. 그것을 `st1.push(st2.top());` 으로 하게 되는 것이다. 그렇게 되면 오른쪽에는 더는 그 문자가 없게 되니깐 pop으로 제거해준다.

```c++
else if (ch == 'B')
		{
			if (st1.size() > 0)
				st1.pop();
		}
```

'B'의 경우는 커서 왼쪽에 있는 문자를 삭제함 (커서가 문장의 맨 앞이면 무시됨) 삭제로 인해 커서는 한 칸 왼쪽으로 이동한 것처럼 나타나지만, 실제로 커서의 오른쪽에 있던 문자는 그대로임, 이와 같은 동작을 해줘야 한다. 커서 왼쪽에 있는 문자 즉 st1의 문자를 pop을 이용해 삭제하면 된다. st2, 즉 오른쪽에 있는 문자는 그대로 있어야 하니깐 아무런 동작도 필요 없다.

```
else if (ch == 'P')
		{
			char add;
			cin >> add;
			st1.push(add);
		}
```

'P'의 경우 $라는 문자를 커서 왼쪽에 추가함, 이와 같은 동작을 위해서는 커서의 왼쪽을 나타내는 st1 에 $라는 문자를 추가해주면 되는 것이다. char 변수를 하나 만들어 push로 넣어주면 된다.

```c++
	for (int i=st1.size(); i>0 ; i--)
	{
		st2.push( st1.top());
		st1. pop();
	}


	for (int i = st2.size(); i > 0; i--)
	{

			cout << st2.top();
			st2.pop();

	}
```

마지막 문자열 출력을 위한 부분이다. 스택의 경우 후입선출을 한다. 즉, 순서대로 출력하려면 가장 먼저 출력 해야 하는 문자가 마지막에 들어가야 한다는 것이다. 그렇게 되려면 st2에 st1의 top을 넣어주면 된다. 넣어줬으니 pop을 통해 삭제한다. 그 후 st2를 출력하면 된다.

예제 입력 1의 경우로 생각해보자. abcd 라는 문자열을 입력했고 명령어의 개수는 3개로  `P x ` `L` `P y` 이다.

`P x` 의 경우 커서의 왼쪽에 'x'라는 문자를 추가하게 될 것이다.  추가하면 st1에는abcdx 가 들어가게 된다.

`L`의 경우 커서를 왼쪽으로 한 칸 이동하게 된다. st1에는abcd 가 남고 st2에는 x가 들어가게 된다.

`P y` 의 경우 커서의 왼쪽에 'y'라는 문자를 추가하게 된다. st1에는abcdy 가 들어가게 되고 st2에는 그대로 x만 있게 된다.

3개의 명령어 입력이  끝났다. 그렇다면 출력을 해보자. 앞에서 말했었던 것처럼 스택은 후입선출이다.   그렇기 때문에 st2에 push를 이용해 st1의 top을 넣어준다. st1의 size만큼 반복하게 되면 xydcba가 되는데 st2의 top을 size만큼 반복하여 출력하게 되면 abcdyx가 된다.

마지막으로 입력받은 명령어 동작을 할 때 `if (st1.size() > 0)` 라고 했는데 `if (!st1.empty())` 라고 할 수도 있다. 또한 마지막에 출력 관련된 부분에서는 for문이 아니라 while 문으로도 가능하다. `for (int i = st2.size(); i > 0; i--)`가 아니라 `while(!st2.empty())`라고도 할 수 있다.